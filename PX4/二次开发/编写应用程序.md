# PX4二次开发--编写应用程序Application
程序入口  xxx_main()

这种函数只会在命令行进行调用
![alt text](image.png)

注意有些入口函数中使用了类模板，使用了ModuleBase类中T::main()

## 不同的编译命令
编译命令 make px4_fmu-v2_default  
- 含义:配置选项在 boards/px4/fmu-v2/default.px4board中   
  
make micoair_h743_default  
- 含义:配置选项在 boards/micoair/h743/default.px4board中  

make px4_sitl_default  
- 含义:配置选项在 boards/px4/sitl/default.px4board中  

如果没有指明default，则会默认编译default  

## 创建功能包源文件
1. 在 /src/examples下创建一个my_example_app 并在该目录下新建一个.c格式的源文件。
   
2. 编写代码
```cpp
#include <px4_platform_common/log.h>


__EXPORT int my_example_app_main(int argc, char *argv[]);

int my_example_app_main(int argc, char *argv[])
{
	PX4_INFO("Hello World!");
	return OK;
}
```

注意必须要遵守命名规范:  
The main function must be named <module_name>_main and exported from the module as shown.  

3. 编写CMakeLists.txt
```bash
px4_add_module(
	MODULE examples__px4_simple_app
	MAIN px4_simple_app
	STACK_MAIN 2000
	SRCS
		px4_simple_app.c
	DEPENDS
	)
```
The px4_add_module() method builds a static library from a module description.

- The **MODULE** block is the Firmware-unique name of the module (by convention the module name is prefixed by parent directories back to src).
  
- The **MAIN** block lists the entry point of the module, which registers the command with NuttX so that it can be called from the PX4 shell or SITL console.
  
-  **DEPENDS** ,当使用工作队列时，要列出 px4_work_queue  

MODULE命名规范
- 影响飞行安全的算法/控制器 → module

- 工具类/辅助功能 → app

- 底层驱动 → 无后缀，使用前缀driver__



1. 创建Kconfig文件,在/src/examples下创建Kconfig文件，编写代码
```
menuconfig EXAMPLES_PX4_SIMPLE_APP
	bool "px4_simple_app"
	default n
	---help---
		Enable support for px4_simple_app
```

1. 修改编译脚本  
应用程序的编写至此完成。 为了运行它，您首先需要确保它是作为 PX4   
对于不同的构建对象，需要修改不同的板级.px4board文件

- PX4 SITL (Simulator): PX4-Autopilot/boards/px4/sitl/default.px4board
  
- Pixhawk v1/2: PX4-Autopilot/boards/px4/fmu-v2/default.px4board
  
- Pixracer (px4/fmu-v4): PX4-Autopilot/boards/px4/fmu-v4/default.px4board

- px4board files for other boards can be found in PX4-Autopilot/boards/  
  
To enable the compilation of the application into the firmware add the corresponding Kconfig key CONFIG_EXAMPLES_PX4_SIMPLE_APP=y in the px4board file **or** run boardconfig make px4_fmu-v4_default boardconfig:
```
examples  --->
    [x] PX4 Simple app  ----
```

## 添加订阅传感器数据功能
为了做一些实用的事情，应用程序需要订阅输入和发布输出（例如电机或伺服命令）。  
px4传感器数据通过uORB以topic形式发布。For this tutorial, we are interested in the SensorCombined topic, which holds the synchronized sensor data of the complete system.    
订阅主题很简单：  
```cpp
#include <uORB/topics/sensor_combined.h>
..
int sensor_sub_fd = orb_subscribe(ORB_ID(sensor_combined));
```

The sensor_sub_fd is a topic handle and can be used to very efficiently perform a blocking wait for new data. 当前线程进入休眠状态，一旦有新数据可用就会被调度器自动唤醒，等待时不消耗任何 CPU 周期。 To do this, we use the poll() POSIX system call.

Adding poll() to the subscription looks like (pseudocode, look for the full implementation below):  
```cpp
#include <poll.h>
#include <uORB/topics/sensor_combined.h>
..
int sensor_sub_fd = orb_subscribe(ORB_ID(sensor_combined));

/* one could wait for multiple topics with this technique, just using one here */
px4_pollfd_struct_t fds[] = {
    { .fd = sensor_sub_fd,   .events = POLLIN },
};

while (true) {
	/* wait for sensor update of 1 file descriptor for 1000 ms (1 second) */
	int poll_ret = px4_poll(fds, 1, 1000);
	..
	if (fds[0].revents & POLLIN) {
		/* obtained data for the first file descriptor */
		struct sensor_combined_s raw;
		/* copy sensors raw data into local buffer */
		orb_copy(ORB_ID(sensor_combined), sensor_sub_fd, &raw);
		PX4_INFO("Accelerometer:\t%8.4f\t%8.4f\t%8.4f",
					(double)raw.accelerometer_m_s2[0],
					(double)raw.accelerometer_m_s2[1],
					(double)raw.accelerometer_m_s2[2]);
	}
}
```

## 测试 uORB 消息订阅
最后一步是通过在 nsh shell 中键入以下内容来启动您的应用程序作为后台进程/任务：  
```shell
px4_simple_app &
```

您的应用程序将在控制台中显示 5 个传感器值（译者注：需要使用后面的完整示例中的代码，如果使用上面的伪代码会连续输出并无法退出），然后退出：  
```
[px4_simple_app] Accelerometer:   0.0483          0.0821          0.0332
[px4_simple_app] Accelerometer:   0.0486          0.0820          0.0336
[px4_simple_app] Accelerometer:   0.0487          0.0819          0.0327
[px4_simple_app] Accelerometer:   0.0482          0.0818          0.0323
[px4_simple_app] Accelerometer:   0.0482          0.0827          0.0331
[px4_simple_app] Accelerometer:   0.0489          0.0804          0.0328
```

## 发布数据
下面我们将展示如何发布姿态主题。

INFO
We've chosen attitude because we know that the mavlink app forwards it to the ground control station - providing an easy way to look at the results.

接口非常简单:初始化要发布的结构体 and advertise the topic:
```cpp
#include <uORB/topics/vehicle_attitude.h>
..
/* advertise attitude topic */
struct vehicle_attitude_s att;
memset(&att, 0, sizeof(att));
orb_advert_t att_pub_fd = orb_advertise(ORB_ID(vehicle_attitude), &att);
```

在主循环中，随时发布信息：
```cpp
orb_publish(ORB_ID(vehicle_attitude), att_pub_fd, &att);
```

## 完整代码

```cpp
/****************************************************************************
 *
 *   Copyright (c) 2012-2019 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file px4_simple_app.c
 * Minimal application example for PX4 autopilot
 *
 * @author Example User <mail@example.com>
 */

#include <px4_platform_common/px4_config.h>
#include <px4_platform_common/tasks.h>
#include <px4_platform_common/posix.h>
#include <unistd.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <math.h>

#include <uORB/uORB.h>
#include <uORB/topics/sensor_combined.h>
#include <uORB/topics/vehicle_attitude.h>

__EXPORT int px4_simple_app_main(int argc, char *argv[]);

int px4_simple_app_main(int argc, char *argv[])
{
	PX4_INFO("Hello Sky!");

	/* subscribe to sensor_combined topic */
	int sensor_sub_fd = orb_subscribe(ORB_ID(sensor_combined));
	/* limit the update rate to 5 Hz */
	orb_set_interval(sensor_sub_fd, 200);

	/* advertise attitude topic */
	struct vehicle_attitude_s att;
	memset(&att, 0, sizeof(att));
	orb_advert_t att_pub = orb_advertise(ORB_ID(vehicle_attitude), &att);

	/* one could wait for multiple topics with this technique, just using one here */
	px4_pollfd_struct_t fds[] = {
		{ .fd = sensor_sub_fd,   .events = POLLIN },
		/* there could be more file descriptors here, in the form like:
		 * { .fd = other_sub_fd,   .events = POLLIN },
		 */
	};

	int error_counter = 0;

	for (int i = 0; i < 5; i++) {
		/* wait for sensor update of 1 file descriptor for 1000 ms (1 second) */
		int poll_ret = px4_poll(fds, 1, 1000);

		/* handle the poll result */
		if (poll_ret == 0) {
			/* this means none of our providers is giving us data */
			PX4_ERR("Got no data within a second");

		} else if (poll_ret < 0) {
			/* this is seriously bad - should be an emergency */
			if (error_counter < 10 || error_counter % 50 == 0) {
				/* use a counter to prevent flooding (and slowing us down) */
				PX4_ERR("ERROR return value from poll(): %d", poll_ret);
			}

			error_counter++;

		} else {

			if (fds[0].revents & POLLIN) {
				/* obtained data for the first file descriptor */
				struct sensor_combined_s raw;
				/* copy sensors raw data into local buffer */
				orb_copy(ORB_ID(sensor_combined), sensor_sub_fd, &raw);
				PX4_INFO("Accelerometer:\t%8.4f\t%8.4f\t%8.4f",
					 (double)raw.accelerometer_m_s2[0],
					 (double)raw.accelerometer_m_s2[1],
					 (double)raw.accelerometer_m_s2[2]);

				/* set att and publish this information for other apps
				 the following does not have any meaning, it's just an example
				*/
				att.q[0] = raw.accelerometer_m_s2[0];
				att.q[1] = raw.accelerometer_m_s2[1];
				att.q[2] = raw.accelerometer_m_s2[2];

				orb_publish(ORB_ID(vehicle_attitude), att_pub, &att);
			}

			/* there could be more file descriptors here, in the form like:
			 * if (fds[1..n].revents & POLLIN) {}
			 */
		}
	}

	PX4_INFO("exiting");

	return 0;
}
```


